<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>protocol/nmt.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h2><a href="https://github.com/DaxBot/node-canopen" target="_blank" class="menu-item" id="repository" >Repository</a></h2><h3>Classes</h3><ul><li><a href="DataObject.html">DataObject</a></li><li><a href="Device.html">Device</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Device.html#getRaw">getRaw</a></li><li data-type='method' style='display: none;'><a href="Device.html#getRawArray">getRawArray</a></li><li data-type='method' style='display: none;'><a href="Device.html#getValue">getValue</a></li><li data-type='method' style='display: none;'><a href="Device.html#getValueArray">getValueArray</a></li><li data-type='method' style='display: none;'><a href="Device.html#init">init</a></li><li data-type='method' style='display: none;'><a href="Device.html#receive">receive</a></li><li data-type='method' style='display: none;'><a href="Device.html#send">send</a></li><li data-type='method' style='display: none;'><a href="Device.html#setRaw">setRaw</a></li><li data-type='method' style='display: none;'><a href="Device.html#setRawArray">setRawArray</a></li><li data-type='method' style='display: none;'><a href="Device.html#setTransmitFunction">setTransmitFunction</a></li><li data-type='method' style='display: none;'><a href="Device.html#setValue">setValue</a></li><li data-type='method' style='display: none;'><a href="Device.html#setValueArray">setValueArray</a></li></ul></li><li><a href="Eds.html">Eds</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Eds.html#addEntry">addEntry</a></li><li data-type='method' style='display: none;'><a href="Eds.html#addSubEntry">addSubEntry</a></li><li data-type='method' style='display: none;'><a href="Eds.html#getEntry">getEntry</a></li><li data-type='method' style='display: none;'><a href="Eds.html#getSubEntry">getSubEntry</a></li><li data-type='method' style='display: none;'><a href="Eds.html#load">load</a></li><li data-type='method' style='display: none;'><a href="Eds.html#removeEntry">removeEntry</a></li><li data-type='method' style='display: none;'><a href="Eds.html#removeSubEntry">removeSubEntry</a></li><li data-type='method' style='display: none;'><a href="Eds.html#save">save</a></li></ul></li><li><a href="EdsError.html">EdsError</a></li><li><a href="Emcy.html">Emcy</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Emcy.html#init">init</a></li><li data-type='method' style='display: none;'><a href="Emcy.html#setHistoryLength">setHistoryLength</a></li><li data-type='method' style='display: none;'><a href="Emcy.html#write">write</a></li></ul></li><li><a href="EmcyMessage.html">EmcyMessage</a><ul class='members'><li data-type='member' style='display: none;'><a href="EmcyMessage.html#.EmcyCode">EmcyCode</a></li><li data-type='member' style='display: none;'><a href="EmcyMessage.html#.EmcyType">EmcyType</a></li></ul></li><li><a href="Lss.html">Lss</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Lss.html#_maskCompare">_maskCompare</a></li><li data-type='method' style='display: none;'><a href="Lss.html#activateBitTiming">activateBitTiming</a></li><li data-type='method' style='display: none;'><a href="Lss.html#configureBitTiming">configureBitTiming</a></li><li data-type='method' style='display: none;'><a href="Lss.html#configureNodeId">configureNodeId</a></li><li data-type='method' style='display: none;'><a href="Lss.html#fastscan">fastscan</a></li><li data-type='method' style='display: none;'><a href="Lss.html#init">init</a></li><li data-type='method' style='display: none;'><a href="Lss.html#inquireProductCode">inquireProductCode</a></li><li data-type='method' style='display: none;'><a href="Lss.html#inquireRevisionNumber">inquireRevisionNumber</a></li><li data-type='method' style='display: none;'><a href="Lss.html#inquireSerialNumber">inquireSerialNumber</a></li><li data-type='method' style='display: none;'><a href="Lss.html#inquireVendorId">inquireVendorId</a></li><li data-type='method' style='display: none;'><a href="Lss.html#storeConfiguration">storeConfiguration</a></li><li data-type='method' style='display: none;'><a href="Lss.html#switchModeGlobal">switchModeGlobal</a></li><li data-type='method' style='display: none;'><a href="Lss.html#switchModeSelective">switchModeSelective</a></li></ul></li><li><a href="LssError.html">LssError</a></li><li><a href="LssTimeout.html">LssTimeout</a></li><li><a href="Nmt.html">Nmt</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Nmt.html#addConsumer">addConsumer</a></li><li data-type='method' style='display: none;'><a href="Nmt.html#enterPreOperational">enterPreOperational</a></li><li data-type='method' style='display: none;'><a href="Nmt.html#getConsumer">getConsumer</a></li><li data-type='method' style='display: none;'><a href="Nmt.html#init">init</a></li><li data-type='method' style='display: none;'><a href="Nmt.html#removeConsumer">removeConsumer</a></li><li data-type='method' style='display: none;'><a href="Nmt.html#resetCommunication">resetCommunication</a></li><li data-type='method' style='display: none;'><a href="Nmt.html#resetNode">resetNode</a></li><li data-type='method' style='display: none;'><a href="Nmt.html#start">start</a></li><li data-type='method' style='display: none;'><a href="Nmt.html#startNode">startNode</a></li><li data-type='method' style='display: none;'><a href="Nmt.html#stop">stop</a></li><li data-type='method' style='display: none;'><a href="Nmt.html#stopNode">stopNode</a></li></ul></li><li><a href="Pdo.html">Pdo</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Pdo.html#addReceive">addReceive</a></li><li data-type='method' style='display: none;'><a href="Pdo.html#addTransmit">addTransmit</a></li><li data-type='method' style='display: none;'><a href="Pdo.html#getReceive">getReceive</a></li><li data-type='method' style='display: none;'><a href="Pdo.html#getTransmit">getTransmit</a></li><li data-type='method' style='display: none;'><a href="Pdo.html#init">init</a></li><li data-type='method' style='display: none;'><a href="Pdo.html#removeReceive">removeReceive</a></li><li data-type='method' style='display: none;'><a href="Pdo.html#removeTransmit">removeTransmit</a></li><li data-type='method' style='display: none;'><a href="Pdo.html#start">start</a></li><li data-type='method' style='display: none;'><a href="Pdo.html#stop">stop</a></li><li data-type='method' style='display: none;'><a href="Pdo.html#write">write</a></li></ul></li><li><a href="SdoClient.html">SdoClient</a><ul class='methods'><li data-type='method' style='display: none;'><a href="SdoClient.html#addServer">addServer</a></li><li data-type='method' style='display: none;'><a href="SdoClient.html#download">download</a></li><li data-type='method' style='display: none;'><a href="SdoClient.html#getServer">getServer</a></li><li data-type='method' style='display: none;'><a href="SdoClient.html#init">init</a></li><li data-type='method' style='display: none;'><a href="SdoClient.html#removeServer">removeServer</a></li><li data-type='method' style='display: none;'><a href="SdoClient.html#upload">upload</a></li></ul></li><li><a href="SdoError.html">SdoError</a><ul class='members'><li data-type='member' style='display: none;'><a href="SdoError.html#.SdoCode">SdoCode</a></li></ul></li><li><a href="SdoServer.html">SdoServer</a><ul class='methods'><li data-type='method' style='display: none;'><a href="SdoServer.html#addClient">addClient</a></li><li data-type='method' style='display: none;'><a href="SdoServer.html#getClient">getClient</a></li><li data-type='method' style='display: none;'><a href="SdoServer.html#init">init</a></li><li data-type='method' style='display: none;'><a href="SdoServer.html#removeClient">removeClient</a></li></ul></li><li><a href="Sync.html">Sync</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Sync.html#init">init</a></li><li data-type='method' style='display: none;'><a href="Sync.html#start">start</a></li><li data-type='method' style='display: none;'><a href="Sync.html#stop">stop</a></li><li data-type='method' style='display: none;'><a href="Sync.html#write">write</a></li></ul></li><li><a href="Time.html">Time</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Time.html#init">init</a></li><li data-type='method' style='display: none;'><a href="Time.html#write">write</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#AccessType">AccessType</a></li><li><a href="global.html#calculateCrc">calculateCrc</a></li><li><a href="global.html#DataType">DataType</a></li><li><a href="global.html#EPOCH_OFFSET">EPOCH_OFFSET</a></li><li><a href="global.html#LssMode">LssMode</a></li><li><a href="global.html#NmtState">NmtState</a></li><li><a href="global.html#ObjectType">ObjectType</a></li><li><a href="global.html#rawToType">rawToType</a></li><li><a href="global.html#typeToRaw">typeToRaw</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">protocol/nmt.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @file Implements the CANopen Network Managements (NMT) protocol.
 * @author Wilkins White
 * @copyright 2021 Daxbot
 */

const Device = require('../device');
const { EdsError, DataObject } = require('../eds');
const { ObjectType, AccessType, DataType } = require('../types');

/**
 * NMT internal states.
 *
 * @enum {number}
 * @see CiA301 "NMT states" (§7.3.2.2)
 */
const NmtState = {
    /** The CANopen device's parameters are set to their power-on values. */
    INITIALIZING: 0,

    /**
     * Communication via SDOs is possible, but PDO communication is not
     * allowed. PDO configuration may be performed by the application.
     */
    PRE_OPERATIONAL: 127,

    /**
     * All communication objects are active. Access to certain aspects of the
     * application may be limited.
     */
    OPERATIONAL: 5,

    /** No communication except for node guarding and heartbeat.  */
    STOPPED: 4,
};

/**
 * NMT commands.
 *
 * @enum {number}
 * @see CiA301 "Node control protocols" (§7.2.8.3.1)
 * @private
 */
const NmtCommand = {
    /** Switch target device to {@link NmtState.OPERATIONAL}. */
    ENTER_OPERATIONAL: 1,

    /** Switch target device to {@link NmtState.STOPPED}. */
    ENTER_STOPPED: 2,

    /** Switch target device to {@link NmtState.PRE_OPERATIONAL}. */
    ENTER_PRE_OPERATIONAL: 128,

    /** Reset the target device. */
    RESET_NODE: 129,

    /** Reset the target device's communication. */
    RESET_COMMUNICATION: 130,
};

/**
 * CANopen NMT protocol handler.
 *
 * The network management (NMT) protocol follows a producer-consumer structure
 * where NMT objects are used to initialze, start, monitor, reset, or stop
 * nodes. All CANopen devices are considered NMT consumers with one device
 * fulfilling the role of NMT producer.
 *
 * This class implements the NMT node control services and tracks the device's
 * current NMT consumer state.
 *
 * @param {Device} device - parent device.
 * @see CiA301 "Network management" (§7.2.8)
 * @example
 * const can = require('socketcan');
 *
 * const channel = can.createRawChannel('can0');
 * const device = new Device({ id: 0xa });
 *
 * channel.addListener('onMessage', (message) => device.receive(message));
 * device.setTransmitFunction((message) => channel.send(message));
 *
 * device.init();
 * channel.start();
 *
 * device.nmt.producerTime = 500;
 * device.nmt.start();
 */
class Nmt {
    constructor(device) {
        this.device = device;
        this.heartbeats = {};
        this.timers = {};
        this._state = NmtState.INITIALIZING;
        this.started = false;
    }

    /**
     * Device NMT state.
     *
     * @type {NmtState}
     */
    get state() {
        return this._state;
    }

    set state(newState) {
        const oldState = this.state;
        if(newState !== oldState) {
            this._state = newState;
            this.device.emit('nmtChangeState', this.device.id, newState);
        }
    }

    /**
     * Producer heartbeat time in ms (Object 0x1017).
     *
     * @type {number}
     */
    get producerTime() {
        return this.device.getValue(0x1017);
    }

    set producerTime(value) {
        let obj1017 = this.device.eds.getEntry(0x1017);
        if(obj1017 === undefined) {
            obj1017 = this.device.eds.addEntry(0x1017, {
                parameterName:  'Producer heartbeat time',
                objectType:     ObjectType.VAR,
                dataType:       DataType.UNSIGNED32,
                accessType:     AccessType.READ_WRITE,
            });
        }

        obj1017.value = value;
    }

    /**
     * Get an entry from 0x1016 (Consumer heartbeat time).
     *
     * @param {number} deviceId - device COB-ID of the entry to get.
     * @returns {DataObject | null} the matching entry.
     */
    getConsumer(deviceId) {
        const obj1016 = this.device.eds.getEntry(0x1016);
        if(obj1016 !== undefined) {
            for(let i = 1; i &lt;= obj1016._subObjects[0].value; ++i) {
                const subObject = obj1016._subObjects[i];
                if(subObject === undefined)
                    continue;

                if(((subObject.value >> 16) &amp; 0x7F) === deviceId)
                    return subObject;
            }
        }

        return null;
    }

    /**
     * Add an entry to 0x1016 (Consumer heartbeat time).
     *
     * @param {number} deviceId - device COB-ID to add.
     * @param {number} timeout - milliseconds before a timeout is reported.
     * @param {number} [subIndex] - sub-index to store the entry, optional.
     */
    addConsumer(deviceId, timeout, subIndex) {
        if(deviceId &lt; 1 || deviceId > 0x7F)
            throw RangeError('deviceId must be in range 1-127');

        if(timeout &lt; 0 || timeout > 0xffff)
            throw RangeError('timeout must be in range 0-65535');

        if(this.getConsumer(deviceId) !== null) {
            deviceId = '0x' + deviceId.toString(16);
            throw new EdsError(`entry for device ${deviceId} already exists`);
        }

        let obj1016 = this.device.eds.getEntry(0x1016);
        if(obj1016 === undefined) {
            obj1016 = this.device.eds.addEntry(0x1016, {
                parameterName:  'Consumer heartbeat time',
                objectType:     ObjectType.ARRAY,
            });
        }

        if(!subIndex) {
            // Find first empty index
            for(let i = 1; i &lt;= 255; ++i) {
                if(obj1016[i] === undefined) {
                    subIndex = i;
                    break;
                }
            }
        }

        if(!subIndex)
            throw new EdsError('failed to find empty sub-index');

        // Install sub entry
        this.device.eds.addSubEntry(0x1016, subIndex, {
            parameterName:  `Device 0x${deviceId.toString(16)}`,
            objectType:     ObjectType.VAR,
            dataType:       DataType.UNSIGNED32,
            accessType:     AccessType.READ_WRITE,
            defaultValue:   (deviceId &lt;&lt; 16) | timeout,
        });
    }

    /**
     * Remove an entry from 0x1016 (Consumer heartbeat time).
     *
     * @param {number} deviceId - device COB-ID of the entry to remove.
     */
    removeConsumer(deviceId) {
        const subEntry = this.getConsumer(deviceId);
        if(subEntry === null)
            throw new EdsError(`entry for device ${deviceId} does not exist`);

        this.device.eds.removeSubEntry(0x1016, subEntry.subIndex);
    }

    /** Initialize members and begin heartbeat monitoring. */
    init() {
        // Object 0x1016 - Consumer heartbeat time
        let obj1016 = this.device.eds.getEntry(0x1016);
        if(obj1016 === undefined) {
            obj1016 = this.device.eds.addEntry(0x1016, {
                parameterName:  'Consumer heartbeat time',
                objectType:     ObjectType.ARRAY,
            });
        }
        else {
            this._parse1016(obj1016);
        }

        // Object 0x1017 - Producer heartbeat time
        let obj1017 = this.device.eds.getEntry(0x1017);
        if(obj1017 === undefined) {
            obj1017 = this.device.eds.addEntry(0x1017, {
                parameterName:  'Producer heartbeat time',
                objectType:     ObjectType.VAR,
                dataType:       DataType.UNSIGNED32,
                accessType:     AccessType.READ_WRITE,
            });
        }
        else {
            this._parse1017(obj1017);
        }

        obj1016.addListener('update', this._parse1016.bind(this));
        obj1017.addListener('update', this._parse1017.bind(this));


        this.device.addListener('message', this._onMessage.bind(this));
    }

    /** Begin heartbeat generation. */
    start() {
        if(this.producerTime == 0)
            throw new EdsError('producer heartbeat time can not be 0')

        // Switch to NmtState.OPERATIONAL
        this.startNode();

        // Start heartbeat timer
        this.timers[this.device.id] = setInterval(() => {
            this._sendHeartbeat();
        }, this.producerTime);

        this.started = true;
    }

    /** Stop heartbeat generation. */
    stop() {
        clearInterval(this.timers[this.device.id]);
        delete this.timers[this.device.id]
        this.started = false;
    }

    /**
     * Service: start remote node.
     *
     * Change the state of NMT consumer(s) to NMT state operational.
     *
     * @param {number} [nodeId] - id of node or 0 for broadcast.
     * @see CiA301 "Service start remote node" (§7.2.8.2.1.2)
     */
    startNode(nodeId) {
        this._sendNmt(nodeId, NmtCommand.ENTER_OPERATIONAL);
    }

    /**
     * Service: stop remote node.
     *
     * Change the state of NMT consumer(s) to NMT state stopped.
     *
     * @param {number} [nodeId] - id of node or 0 for broadcast.
     * @see CiA301 "Service stop remote node" (§7.2.8.2.1.3)
     */
    stopNode(nodeId) {
        this._sendNmt(nodeId, NmtCommand.ENTER_STOPPED);
    }

    /**
     * Service: enter pre-operational.
     *
     * Change the state of NMT consumer(s) to NMT state pre-operational.
     *
     * @param {number} [nodeId] - id of node or 0 for broadcast.
     * @see CiA301 "Service enter pre-operational" (§7.2.8.2.1.4)
     */
    enterPreOperational(nodeId) {
        this._sendNmt(nodeId, NmtCommand.ENTER_PRE_OPERATIONAL);
    }

    /**
     * Service: reset node.
     *
     * Reset the application of NMT consumer(s).
     *
     * @param {number} [nodeId] - id of node or 0 for broadcast.
     * @see CiA301 "Service reset node" (§7.2.8.2.1.5)
     */
    resetNode(nodeId) {
        this._sendNmt(nodeId, NmtCommand.RESET_NODE);
    }

    /**
     * Service: reset communication.
     *
     * Reset communication of NMT consumer(s).
     *
     * @param {number} [nodeId] - id of node or 0 for broadcast.
     * @see CiA301 "Service reset communication" (§7.2.8.2.1.6)
     */
    resetCommunication(nodeId) {
        this._sendNmt(nodeId, NmtCommand.RESET_COMMUNICATION);
    }

    /**
     * Serve an NMT command object.
     *
     * @param {number} nodeId - id of node or 0 for broadcast.
     * @param {NmtCommand} command - NMT command to serve.
     * @private
     */
    _sendNmt(nodeId, command) {
        if(nodeId === undefined || nodeId === this.device.id) {
            // Handle internally and return
            this._handleNmt(command);
            return;
        }

        if(nodeId === 0) {
            // Broadcast
            this._handleNmt(command);
        }

        this.device.send({
            id:     0x0,
            data:   Buffer.from([command, nodeId]),
        });
    }

    /**
     * Serve a Heartbeat object.
     *
     * @private
     */
    _sendHeartbeat() {
        this.device.send({
            id: 0x700 + this.device.id,
            data: Buffer.from([this.state])
        });
    }

    /**
     * Parse an NMT command.
     *
     * @param {NmtCommand} command - NMT command to handle.
     * @private
     */
    _handleNmt(command) {
        switch(command) {
            case NmtCommand.ENTER_OPERATIONAL:
                this.state = NmtState.OPERATIONAL;
                break;
            case NmtCommand.ENTER_STOPPED:
                this.state = NmtState.STOPPED;
                break;
            case NmtCommand.ENTER_PRE_OPERATIONAL:
                this.state = NmtState.PRE_OPERATIONAL;
                break;
            case NmtCommand.RESET_NODE:
            case NmtCommand.RESET_COMMUNICATION:
                this.state = NmtState.INITIALIZING;
                break;
        }
    }

    /**
     * Called when a new CAN message is received.
     *
     * @param {object} message - CAN frame.
     * @param {number} message.id - CAN message identifier.
     * @param {Buffer} message.data - CAN message data;
     * @param {number} message.len - CAN message length in bytes.
     * @private
     */
    _onMessage(message) {
        if((message.id &amp; 0x7FF) == 0x0) {
            const nodeId = message.data[1];
            if(nodeId == 0 || nodeId == this.device.id)
                this._handleNmt(message.data[0]);
        }
        else if((message.id &amp; 0x700) == 0x700) {
            const deviceId = message.id &amp; 0x7F;
            if(deviceId in this.heartbeats) {
                this.heartbeats[deviceId].last = Date.now();

                const state = message.data[0];
                if(state !== this.heartbeats[deviceId].state) {
                    this.heartbeats[deviceId].state = state;
                    this.device.emit('nmtChangeState', deviceId, state);
                }

                if(!this.timers[deviceId]) {
                    // First heartbeat - start timer.
                    const interval = this.heartbeats[deviceId].interval;
                    this.timers[deviceId] = setTimeout(() => {
                        this.device.emit('nmtTimeout', deviceId);
                        this.heartbeats[deviceId].state = null;
                        this.timers[deviceId] = null;
                    }, interval);
                }
                else {
                    this.timers[deviceId].refresh();
                }
            }
        }
    }

    /**
     * Called when 0x1016 (Consumer heartbeat time) is updated.
     *
     * @param {DataObject} entry - updated DataObject.
     * @private
     */
    _parse1016(entry) {
        /* Object 0x1016 - Consumer heartbeat time.
         *   sub-index 1+:
         *     bit 0..15    Heartbeat time in ms.
         *     bit 16..23   Node-ID of producer.
         *     bit 24..31   Reserved (0x00);
         */
        for(let i = 1; i &lt;= entry[0].value; ++i) {
            const subEntry = entry[i];
            if(subEntry === undefined)
                continue;

            const heartbeatTime = subEntry.raw.readUInt16LE(0);
            const deviceId = subEntry.raw.readUInt8(2);

            if(this.heartbeats[deviceId] !== undefined) {
                /* Clear the timer - it will be re-initialized with the new
                 * interval on the next heartbeat message.
                 */
                this.heartbeats[deviceId].interval = heartbeatTime;
                clearTimeout(this.timers[deviceId]);
                this.timers[deviceId] = null;
            }
            else {
                this.heartbeats[deviceId] = {
                    state:      null,
                    interval:   heartbeatTime,
                }
            }
        }
    }

    /**
     * Called when 0x1017 (Producer heartbeat time) is updated.
     *
     * @param {DataObject} entry - updated DataObject.
     * @private
     */
    _parse1017(entry) {
        if(!this.started)
            return;

        // Clear old timer
        this.stop();

        // Start heartbeat timer with new interval
        const producerTime = entry.value;
        if(producerTime > 0) {
            this.timers[this.device.id] = setInterval(() => {
                this._sendHeartbeat();
            }, producerTime);
        }
    }
}

module.exports=exports={ NmtState, Nmt };
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>


<script src="scripts/collapse.js" defer></script>


</body>
</html>
